21.02
(V)Подключить гит,
проработать архитектуру запросов по таблице с двойным ключом (в частности, таб. расписание), особенно put-запрос,
прописать документацию в swagger`е,
реализовать получение данных из связанных таблиц
проработать запросы для отправки "полноценных" данных (а не ИД) при работе с расписанием.

найти способ убрать "лишние" поля при использовании шаблона для запроса со стороны клиента ради избегания исключений 
	(не самое страшное, если есть "доки")
Изучить коллекции (похоже, предпочтительно использовать словари), найти способ оптимизировать код

вопрос: почему бы вместо перезаписи полей исходного экземпляра модели при put-запросах не передавать в переменную
	новые данные, что позволит привести код к единому виду и выделить повторение в метод
	возможная проблема: модель также ссылается на другие модели, если содержит внешние ключи. Пользователь ссылки на модели 
	передавать не должен, как и определять экземпляры "главных" моделей. 

==========================
[11:31, 22.02.2023] Сыч обыкновенный: Пока могу назвать следующее:

Первый и самый важный недостаток - swagger при put и post запросах предлагает заполнить не только данные записи,
но и данные из связанных таблиц, а также данные полей, которые автоматически заполняются при добавлении 
записи (auto_increment), что при некорректном ввводе со стороны клиента может повлечь исключение. Возможных вариантов 
решения проблемы вижу два: добавление комменатриев, которые отображаются на стороне клиента в сваггере (в ms learns 
видел что-то подобное, но подробно изучить раздел и реализовать не успел) описывающих корректный формат ввода, а также 
использование анонимных типов в качестве аргументов в методах mapPost и mapPut, что, гипотетически, должно изменить 
список запрашиваемых параметров и несколько упростит работу фротендера, но этот вариант не тестировал и предполагаю, 
что это может привести к ошибкам в Put-запросах и однозначно потребует переписывания алгоритма в методах Post-запросов.

А, и ещё нужно указать, что при работе с полем типа "dateOnly" стоит передавать не значение полей типа, а просто строку 
формата "yyyy-mm-dd", что корректно обрабатывается программой и записывается в БД.
---UPD:
сваггер отказывается документировать MapGet-методы (которые вызовы методов, а не их определение). Другие не пробовал.
В интернете код у всех выглядит не так: определяются методы обработки запроса вместе с аннотациями. Рабочих вариантов 
решения проблемы пока не вижу, хотя есть идея вынести лямбда-выражения в делегаты, которые и описать 
(но очевидно нерабочее решение всё же. Да ведь?..)
---UPD:
Я дурак. И да, решение более чем рабочее.

Второй недостаток - при get-запросах не подтягиваються значения связанных полей, но можно оставить это как "фичу" при 
запросах всей таблицы, а при запросах отдельных записей по индексу передавать свойству внешнего ключа ссылку на модель 
связанной таблицы, выдавая клиенту расширенные данные при запросе конкретных записей. 
---UPD: 
прямая передача значения создаёт цикл между внешним и первичным ключами двух таблиц и генерирует исключение.
Лечится удалением из подтягиваемой таблицы запрашиваемой записи. Но пробовал я только через навигационное свойство 
внешнего ключа у студентов. Возможно, у них это трогать и не... хотя, а зачем мне список... нет, список одногруппников 
желателен. Нужно как-то убрать цикл и отправлять данные о всех студентах группы. Но для этого нужно сначала заполнить 
список у модели, собственно, группы.

Третий - на мой взгляд, код слишком избыточен, код методов однотипных запросов практически полностью повторяется, за 
исключением значений типов и именований свойств. Как следствие, изменение алгоритма одного типа запросов требует 
переписывания всех однотипных методов (здесь их пока не много, но в боевом программировании, уверен, счёт таблиц идёт 
на десятки или даже сотни).
Как решить проблему пока не знаю. Думал провернуть финт ушами с определением коллекции вроде словаря для сопоставления 
свойств моделей и строки с их названием и определением обобщённого делегата, чтобы код 
"Student? output = db.Students.FirstOrDefaultAsync(predicate);" можно было заменить на что-то вроде 
"model? output = await db.GetData("students").FirstOrDefaultAsync(predicate);", но как передать собственно строку и 
тип, если методы запросов принимают в качестве параметров только URl для вызова соответствующего Map-метода и делегат
для обработки запроса - я пока не придумал. Вполне возможно, что никак. Я знаю, что есть также рефлексия, которая, в 
теории, может решить данную проблему, но, насколько я знаю, она очень затратна по ресурсам системы (насколько затратна 
и целесообразно ли её использовать - тоже вопрос, практики использования нет).
---UPD:
экспериментально обнаружил, что в Map-метод можно передавать делегат с любым набором параметров с базовыми типами, но
в этом случае они запрашиваются у клиента. 

[17:40, 22.02.2023] Сыч обыкновенный: Сейчас ещё кое-что вспомнил: расписание у меня представляет таблицу из двойного 
первичного ключа и внешних ключей, которые ссылаются на ИД таблиц групп, дисциплин и преподов. В рамках организации 
базы данных такой подход логичен, но вот пользователю нужно сразу отправлять название дисциплин и имя препода, а не их 
номера (или, как минимум, вместе с ними сразу делать запросы нужных данных). Пока это не исправлено.
	
